<!DOCTYPE html>
<html class="no-js" lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTB: RopeTwo Writeup - </title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="PwnFuzz Blog" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/img/pwnfuzz.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">PwnFuzz Blog</div>
					<div class="logo__tagline">Just another site</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/">
				
				<span class="menu__text">Home</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/tags/">
				
				<span class="menu__text">Tags</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>

		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTB: RopeTwo Writeup</h1>
			
		</header>
		<div class="content post__content clearfix">
			<p>This box was without a second thought one of the favourite box of mine on HackTheBox so far, since I am more of a pwn and reverse engineering person, this machine was a challenge, an outstanding one which pushed my learning skills more further because upto the moment I really went into this, I was not a good at heap exploitation, more skeptical about the V8 exploitation skills of mine and of course I knew nothing of the kernel pwn, so this was a way to tackle every weakness of mine, hope you find the writeup useful, I&rsquo;ll include the link of the attachments at the very bottom to my files, QEMU enviornment for the kernel pwn and the exploits, without further ado, let&rsquo;s start.</p>
<h1 id="foothold">Foothold</h1>
<p>So, as this became kind of obvious that the foothold required the V8 exploitation as the rumors went by. But apart from that, I started scanning the ports as I was unclear myself where and how things are on this machine, now starting off, I used nmap to scan the ports:-</p>

<p>The port 22 was open, being the SSh, the other two were the ones running the webserver, port 5000 was running the GitLab and the port 8000 running a webserver.
Checking the port 5000:</p>
<p><img src="/img/ropetwo/8000.png" alt="">
It seemed like the portfolio for a company showing their own version of V8 engine, which is the JavaScript Engine for the chromium based browsers, there was a download link for the browser, so without any second thought I downloaded it.</p>
<p>From the name of the archive it seemed like the chromium browser compressed into the POSIX tar archive, after extracting it seemed like the chromium browser as we expected it to be, although running it, just spawned the chromium browser, so that was it, nothing special came out of this.</p>
<p>Now, that being aside, the only port that was 8000, we had a link at the footer of the page which said <strong>Source</strong>, opening the link, we immediately see a subdomain <code>gitlab.ropetwo.htb</code>, which was as follows:-</p>
<p><img src="/img/ropetwo/gitlab.png" alt=""></p>
<h2 id="v8-exploitation">V8 Exploitation</h2>
<p>We immediately, sees a commit which was made, as I did some v8 pwn, I went to check on commit and found the <code>diff</code> file, using so, I moved further and started building v8 engine binary d8, I used the commit, prior to the <code>r4j</code> user made, which was at <a href="http:///gitlab.rope2.htb:5000/root/v8/commit/d91e8d8fca64679c8df05603b5ff7e58709c4801">here</a></p>
<p>Now, first of all, we didn&rsquo;t has much thing to get started, as for starting to pwn the v8 engine of it, we had to build the binary named <code>d8</code>, since that was not provided. I fetched the v8 engine code from the google and checkout the last commit which was mentioned in the GitLab, following are the steps one could replicate to make their own version of the d8 by applying the <code>diff</code> file.</p>

<p>This took some time, approximately 3 hours on my VM which had 3GB of RAM and 1 core, though I made both the debug version and release version, but the release version was more helpful because before doing this v8 exploitation challenge, I did the DownUnderCTF&rsquo;s &ldquo;Is it Pwn or Web?&rdquo; challenge which was close to same to this one, that being said, let&rsquo;s get started.</p>
<blockquote>
<p>Attachment: The <code>d8</code> binary and the exploits can be found here: <a href="https://github.com/D4mianWayne/PwnLand/tree/master/CTFs/RopeTwo_HackTheBox/Foothold">https://github.com/D4mianWayne/PwnLand/tree/master/CTFs/RopeTwo_HackTheBox/Foothold</a></p></blockquote>
<p>The only obstacle one would really stumble upon during this challenge is the use of the Pointer Compression, this made the address representation in 32 bit, which resulted in the leak being hard to make something of, since the isolate root, the upper 32 bit value of an address which is used to access the data around the V8 heap turned out to be an issue. But going through this <a href="">blog</a>, this mentioned that we do not need to know about the isolate root address, if we could manage to massage the vulnerability to get <code>fakeobj</code> and the <code>addrof</code> primitive, then we can get through the pointer compression which would result in not being a problem.</p>
<p>First of all, we need to analyse the patch file such that we spot which commit specifically pushed changes and pushed it where exactly:-</p>

<p>Breaking this down, the following lines:-</p>

<p>Here the <code>/src/builtins/builtins-array.c</code> is used to denote that there are some new functions which are being added, this being mentioned the following two functions which were added here is the <code>ArrayGetLastElement</code> and the <code>ArraySetLastElement</code>, let&rsquo;s break those down one by one:-</p>
<ul>
<li>
<p>The <code>ArrayGetLastElement</code> as the name implies, it gets the last element from the array, first off it calculates the length in the variable <code>len</code> the returns the element stored as the <code>len</code> index, now i =f you pay attention here, the <code>len</code> here is an absolute length of the array, we know that since an array indexing starts from the <code>0</code>, to access the 0th element we do <code>array[0]</code> but here since the element is stored in an array and the value which is at the <code>len</code> index is being hence allowing us for Out-Of-Bound read by 1 element.</p>
</li>
<li>
<p>The <code>ArraySetLastElement</code> as the name says, this built-in function saves the value to the last index of the array, now here, as of the previous function, the <code>len</code> is counted by the length of the array and then elements defined would be overwritten at that index, <code>array[index] = element</code>. Yes, you&rsquo;re thinking corrrectly, we have Out-Of-Bound write here too but by 1 element.</p>
</li>
</ul>
<p>So, as above mentioned we know that there are 2 functions that we have use in order to exploit this specific patch of the binary and eventually the chrome browser.</p>
<p>As this is also going to be very detailed blog post, we will understand the concepts first then we will move on eventually.</p>
<p>As JavaScript is a dynamically typed language, the engine must store type information with every runtime value. In v8, this is accomplished through a combination of pointer tagging and the use of dedicated type information objects, called Maps. These Maps are used to keep the track of the objects created at runtime, since this is how objects are handle, overwriting the map would lead to some internal type confusion within the V8 engine itself.
As of now, you might be thinking how exactly we access Maps and most importantly &ldquo;How do we recognize a Map?&rdquo;, for this I used the debug version of the <code>d8</code> binary. that binary when run with the <code>allow-natives-syntax</code> will let you use the <code>%DebugPrint(&lt;object&gt;)</code> which will print the related information of the objects, let&rsquo;s say, for example, we declared the array with the elements and then use the <code>%DebugPrint(arr)</code> to get all the information about an objects including but not limited to:-</p>
<ul>
<li>Map address</li>
<li>Element Pointer</li>
<li>Type Information etc.</li>
</ul>

<p>Now, breaking it down, we have the <code>arr</code> located at the <code>0xe81080c5e45</code> which is of type <code>JSArray</code> and it has it&rsquo;s map located at the <code>0x0e8108281909</code>, other than that, according to the information, it has a map of <code>PACKED_DOUBLE_ELEMENTS</code> which references to the <code>arr</code> having elements of double type. The element pointer is located at the <code>0x0e81080c5e25</code> which is of length 3 and is of type <code>FixedDoubleArray</code>. Now, using the gdb, we check the memory contents around the <code>arr</code>.</p>
<blockquote>
<p>To check the memory contents of the address, we need to subtract 1 from the address, such that we get absolute address for the analysis.</p></blockquote>

<p>From the debug information, using the <code>%DebugPrint(arr)</code>, and the gdb output, we can see that the 1st element belongs to the map of the array itself, the second belongs to the Properties, the third belongs to the elements array. If you pay attention, I used the <code>x/wx</code> which will show the address as 32 bit representation, the thing here is, the version of the commit made to the V8 engine was after the integration of the pointer compression, which made the addresses to be representated as the 32 bit integer.</p>

<p>Now, since we know how an array is represented into the V8 heap and we also know that we have Off by One read and write vulnerability, which draw us to the conclusion of the we have the ability to overwrite the Map of an object. With this in mind, let&rsquo;s move on:-</p>
<hr>
<p>First off, we need to make the utility functions such that we can deal with the pointer tagging and change the floating values to decimal and vice versa. The following JavaScript function will let us do the work mentioned:-</p>

<p>The above functions are used to convert the float to integer and integer to floats, since the memory address are going to be overwritten by their respected values as float, we need those.</p>
<p>Moving on, we need to create some float arrays, to get the required leaks, we also need them for doing the <code>fakeobj</code> and the <code>addrof</code> primitve, without further ado, let&rsquo;s start:-</p>

<p>These are the variables that will be involved further in the exploit, next off, we need to get the <code>addrof</code> primitve, this means we need to leverage the off by one to read address of an object, let&rsquo;s see:-</p>

<p>Here, first we get the map address of the <code>float_arr</code> and the <code>reg</code> array, then we have a function named <code>addrof</code>, this takes an object as the argument that would be the object address we need to get the address of, what we do is first overwrite the <code>float_arr</code> map object with the <code>reg</code> array, this means, as of now, the map address of the <code>float_arr</code> is pointing to the map of the <code>reg</code> array, then we make the first object of the <code>float_arr</code> to that of object we need to get the address of, then we place the map of the <code>float_arr</code> right back to where it was.</p>
<p><img src="/img/ropetwo/addrof.png" alt="addrof primitve"></p>
<p>Considering, we have a map leak, if we try to read what is stored at that address, it will result in:-</p>

<p>Success, with this out of the way, as of the v8 exploitation goes, we need to have a <code>fakeobj</code> primitive. The <code>fakeobj</code> function is below:-</p>

<p>Let&rsquo;s talk about the <code>fakeobj</code> function, this primitive, in context of this vulnerability and specific patch, we put the address of the fake object we want to put, it is placed onto the first element of the <code>float_arr</code>, then we changed the map of the <code>float_arr</code> to the <code>reg</code> array&rsquo;s map, so when we tend to access the data from the 0th index, how this works is:-</p>
<p><img src="/img/ropetwo/fakeobj.png" alt="fakeobj primitive"></p>
<ul>
<li>We put the address of the object we wamt to overwrite another object with.</li>
<li>Set the map of the map of the <code>float_arr</code> to the map of the <code>reg</code></li>
<li>Get the fake object from the <code>float_arr</code></li>
<li>Put the map of the <code>float_arr</code> back to it&rsquo;s original place</li>
</ul>
<p>These are the primitives, we needed to have before we jump into the read/write primitive, although with these out of the way, we can now work on our functions <code>arb_read</code> and <code>arb_write</code> which will be used to read address from/write values to an address respectively.</p>
<p>Moving on, the arbitrary read function is of interested and I&rsquo;ll try my best to explain, for the moment, consider the following function which is used to read a value from the arbitrary address:-</p>

<p>This function works by first, making a fake object via the <code>fakeobj</code> function, then we put the address we want to read from, it is written to the 1st index of the <code>rw_helper</code> array, then the first element from the <code>fake</code> object is wrong, this is the follow up of the function, which left the understanding of the whole logic, I explained it in steps with the help of the the <code>d8</code> binary and showing it:-</p>
<hr>
<p>We create the <code>fakeobj</code>with the address of the <code>rw_helper</code>, we subtracted <code>0x20</code> from it because the 32 bytes are for the layout of the memory, in this case, we did it because&gt;:-</p>

<p>As for the write function, that also worked on the same princpile of the read function:-</p>

<p>This, if we break down the logic:-</p>
<ul>
<li>This, if compared to the function of the <code>arb_read</code>, this instead of returning the first value from <code>fake</code> array which was the result of faking the object, it overwrites the value that was stored at the first index.</li>
</ul>

<p>The above is from the <code>arb_read</code>.</p>

<p>This is done by overwriting the value which was <em>being returned</em> in ther <code>read</code> function, from here we will leverage for the inital writing to, what we refer as the <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WebAssembly Page in JS</a>, so initially, you cannot start off with the classic pwn challenges one could use the approach of overwriting the <code>__free_hook</code> with of <code>system</code>, then spawn a shell, in the v8 based challenges, mostly CTFs, this is done by creation of a wasm function which would result in the creation of a <code>rwx</code> permission page in the memory layout of the program, from here the approach is following:-</p>
<ul>
<li>Find the <code>rwx</code> segment address, calculate the address of it.</li>
<li>Write the shellcode to the area of the <code>rwx</code> segment.</li>
<li>Call the wasm function created earlier, since shellcode would be written to that function, calling it will eventually result in the shellcode execution.</li>
</ul>

<p>This is the JS code which is used to create <code>pwn</code> function which would reside in the <code>rwx</code> section, with this step aside, let&rsquo;s move on:-</p>

<p>First off, we needed to find the base address of the <code>rwx</code> segment, this was easier to find since, all I had to do is to find the address stored throught the memory and from what offset, it was exactly located at, I used the <code>gef</code>&rsquo;s <code>search-pattern rwx_address</code> and found the reference of that memory located at the offset <code>wasm_instance_addr + 0x68</code>:-</p>

<p>With the above out of the way, we need to know make use of <code>DataView</code> and <code>ArrayBuffer</code> as this will help you in overwriting the address with the desired value, in short these two functions allows you to write the data in binary format using the <code>ArrayBuffer</code>.</p>

<p>The backing store of an <code>ArrayBuffer</code> can be considered as same as the elements pointer of a <code>JSArray</code>. It is found at offset <code>&amp;ArrayBuffer+0x14</code>, which you can find out by using the <code>x64.debug</code> version of <code>d8</code> binary. The principle of this is that instead of using a <code>fakeobj</code> to write directly to an arbitrary address, we use the fakeobj to do the <code>arb-write</code> and modify the backing store of a legitimate ArrayBuffer to our arbitrary address, which in this case would be overwritten with the <code>rwx</code> segment. Now, we can use <code>dataview.setBigUint64(0, val, true)</code> to write our val as a little-endian 64 bit value to our arbitrary address. This is shown below:-</p>

<p>Now, this aside, we just call the function <code>pwn</code> which would result in the execution of the shellcode:-</p>

<p>Run the exploit as <code>./d8 ./xpl.js</code> and we will see a successful calc pop:-</p>
<p><img src="/img/ropetwo/d8_calc.png" alt="calc_pop_d8"></p>
<p>As it worked on <code>d8</code>, we must try it on the chrome binary which was distributed along from the port 8000, to run the exploit, we have to make a HTML file in which we will include the <code>pwn.js</code> file, the idea here is to use <code>--no-sandbox</code> which ultimately means no sandbox escape is being and all the JIT code must be executed on the system itself, the HTML file:-</p>

<p>Running the given chrome binary as <code>./chrome --no-sandbox ./xpl.html</code> resulted in the calculator being popped:-</p>
<p><img src="/img/ropetwo/chrome_calc.png" alt="chrome calc pop"></p>
<p>Now, with this aside, first off I changed the shellcode from the previous to reverse shell shellcode, for which we will be using the exploit to get reverse shell, the final exploit looked like this:-</p>

<p>Now, the obstacle was, where exactly are we supposed to submit the exploit to, there are no chrome instance running on any port, is there? But then, there was this <code>/contact</code> on the port 8000, at this point, I wasn&rsquo;t sure much either, so knowing the comment kind of template might have the XSS vulnerability, this was the only way that seemed to make sense, so giving the exploit as <code>&lt;script&gt;exploit&lt;/script&gt;</code> in the message body and having our netcat listener waiting for the connection, we get the shell as <code>chromeuser</code>
<img src="/img/ropetwo/foothold.png" alt=""></p>
<h1 id="user">User</h1>
<p>After getting the foothold on the machine as <code>chromeuser</code>, looking over in the <code>/home</code> folder there were two directories which include <code>r4j</code> and <code>chromeuser</code> and since the <code>/home/chromeuser</code> didn&rsquo;t had <code>user.txt</code> or anything else that would hint towards something, I started doing the basic enumeration for finding the SUID binaries, which showed the following binaries:-</p>
<p><img src="/img/ropetwo/ssh.png" alt=""></p>

<p>Out of all the listed binaries, the <code>rshell</code> stood out the most, running the binary was functioning as follows:-</p>

<p>Knowing the author, I assumed this <code>rshell</code> binary is going to be about binary exploitation, this meant it was time to transfer it to the machine of mine and start to dissect it to know the flow of it.</p>
<h2 id="tcache-heap-exploitation">Tcache Heap Exploitation</h2>
<hr>
<h5 id="main-function"><code>main</code> function</h5>

<p>The <code>main</code> functions runs in a <code>while</code> loop, then it takes input via <code>read</code> showing the prompt <code>$</code>, there&rsquo;s a call to the <code>initialize</code> function which was as follows:-</p>

<p>It just setus the buffereing and do <code>memset</code> on the global array named <code>directory_file_pointers</code>, the <code>rshell</code> function was defined as follows. The <code>rshell</code> function seems to have 4 options including <code>id</code>, <code>ls</code>, <code>add</code>, <code>rm</code> and <code>edit</code> which proposed the basic functionality of the shell:-</p>

<blockquote>
<p>Allocated chunks here are referred to files in context of the binary</p></blockquote>
<p>Seeing this, when we do <code>ls</code>, it calls <code>print_directory</code> which showed the list of allocated files, then for <code>add</code>, <code>edit</code> and <code>rm</code> it calls their respective functions and the last one being the <code>id</code> which just prints the string <code>uid=1000(r4j) gid=1000(r4j) groups=1000(r4j)</code>, so this was doing nothing,</p>
<hr>
<h5 id="add-function"><code>add</code> function</h5>
<p>This function was responsible for handling the workflow of adding new files:-</p>

<p>I&rsquo;d advise you to go through the code yourself, but the functionality of this function can be summed up as following:-</p>
<ul>
<li>First off, it checks if there&rsquo;s no allocated chunks already if it does, whether it exceeds the memory limit, if so, print <code>&quot;Memmory Error&quot;</code>.</li>
<li>Second, it iterates over the allocated chunks and comapare if the chunk name we are allocating is already available or not.</li>
<li>Then it asks for the size and checks if it is less than <code>0x78</code> or not, <strong>the size constraint hinted towards the tcache</strong>.</li>
<li>Then it allocates a chunk on heap with the size defined and attempt to take the input via <code>fgets</code> on that chunk.</li>
</ul>
<p>The takeaways from this function are as follows:-</p>
<ul>
<li>The number of chunks(files) we can add is 2 at most.</li>
<li>The size accepted for the chunk allocation is restricted to the 0x78, for which we can safely assume we will deal with tcache.</li>
</ul>
<h5 id="rm-function"><code>rm</code> function</h5>
<p>The <code>rm</code> function which was responsible for removing chunks(files) from the binary was handled by this function:-</p>

<p>This function was responsible for deleting files(chunks) from the global array, the function can be summed up as:-</p>
<ul>
<li>It checks whether te specified files is in the gloabl array <code>directory_file_pointer</code>.</li>
<li>Then it does the <code>memset(chunk, 0x0, 0xc8)</code> which means whatever content was stored at that chunk would be <code>0x0</code> once we do <code>rm</code>.</li>
<li>After that, it <code>free</code> that chunk and set the global pointer to NULL, totally making this function from being a victim of Use After Free.</li>
</ul>
<p>Takeaways from this functions are:-</p>
<ul>
<li>Once <code>free</code>&rsquo;d, the chunks would not contain any data.</li>
<li>After being <code>free</code>&rsquo;d, it NULLs out the global pointer which held the pointer for the heap chunks.</li>
<li>No <strong>Use After Free</strong> from this function.</li>
</ul>
<h5 id="edit-function"><code>edit</code> function</h5>
<p>We also have a function called <code>edit</code>, this one was of a great interest:-</p>

<p>Did you saw the catch here? If not, don&rsquo;t worry, I couldn&rsquo;t either at first time, but let&rsquo;s break down the functionality of this function such that the logic of it becomes clear:-</p>
<ul>
<li>First off, this function checks whether the file(chunk), we requested for the edit is in the global arrat <code>directory_file_pointer</code> or not, if it does, proceed.</li>
<li>Then it asks for the <code>size</code>, for which it&rsquo;ll be used to read new content.</li>
<li>The size constraint here also hinted towards the <code>tcache</code> involvement.</li>
<li>Then it does <code>realloc</code> with the size given and second argument being the chunk.</li>
<li>Attempt to read into that extended chunk with the new data we wanted to store.</li>
</ul>
<hr>
<h5 id="vulnerability">Vulnerability</h5>
<p>The cue for this binary was the <code>edit</code>, pretty expected coming from heap challenge, for most part the vulnerability always seem to have in <code>edit</code> functionality provided by the binary. In this case, the vulerability arises from the use of the function <code>realloc</code>, for this if we refer to man pages, we can see how this was the point of the vulnerability:-</p>
<blockquote>
<p>The  realloc() function changes the size of the memory block pointed to
by ptr to size bytes.  The contents will be unchanged in the range from
the start of the region up to the minimum of the old and new sizes.  If
the new size is larger than the old size, the added memory will not  be
initialized.   If  ptr  is  NULL,  then  the call is equivalent to mal‐
loc(size), for all values of size; if size is equal to zero, and ptr is
not  NULL,  then  the  call  is equivalent to free(ptr).  Unless ptr is
NULL, it must have been returned by an earlier call to  malloc(),  cal‐
loc(),  or realloc().  If the area pointed to was moved, a free(ptr) is
done.</p></blockquote>
<p>Did you notice? Yes, calling <code>ralloc(0, &amp;chunk)</code> is basically calling <code>free(&amp;chunk)</code>, this is the cue, we have a <strong>Use After Free</strong> vulnerability in the <code>edit </code>function. Since there&rsquo;s no check for the size being <code>0</code>, as it only checks whether the given size is the within <code>0x70</code> this made the use of <code>realloc</code> function vulnerable here, making this the way to exploit the binary.</p>
<hr>
<p>For this challenge, it would have been lot more easier if we had the GLIBC 2.27 instead of the GLIBC 2.29, since GLIBC 2.27 instroduced the <code>tcache</code> mechanism to a greater range of users and systems, it had quit a lot amount of flaw in the use of <code>tcache</code> which made them suspectible to vulnerabilites like double free, but as the vulnerabilities got reported, this resulted in some major change sin the LIBC 2.29, with the following security mechanism but not only limited to those:-</p>
<ul>
<li>Added checks for the double free which made it harder to propogate this vulnerability.</li>
<li>Increase in assertion check of the size.</li>
<li>Unsorted bin attack is not easy applicable.</li>
</ul>
<p>Although, we don&rsquo;t have to deal with the <strong>Unsorted bin</strong> attack, and with the added checks for the double free, it makes the challenge much more difficult, making for us to bang our heads more than we already been doing.</p>
<p>We have to deal with the checks for the double free, which we will see later on.</p>
<p>The functions responsible for placing and retrieving the chunks out of the <code>tcache</code> are as follows:-</p>

<p>As you can see, from <a href="https://github.com/D4mianWayne/PwnLand/blob/master/Heap/GLIBC%202.27/tcache-overview.md">this</a> there are no checks for double free, on the other hand, since the target system has the GLIBC 2.29 and above code snippet has a check for double since there&rsquo;s a use of <code>e-&gt;key</code> for the chunk, this made the challenge harder than usual.</p>
<hr>
<p>First off, with the complication of the binary, we will try to do this with the ASLR off, to get the basic understanding of the exploit, then using it as base, we will proceed with it. In order to get over the workflow of heap management, I&rsquo;d advise you to go through following links:-</p>
<ul>
<li><a href="https://github.com/D4mianWayne/PwnLand/blob/master/Heap/GLIBC%202.27/tcache-overview.md">https://github.com/D4mianWayne/PwnLand/blob/master/Heap/GLIBC%202.27/tcache-overview.md</a></li>
<li><a href="https://jjy-security.tistory.com/10&amp;prev=search&amp;pto=aue">https://jjy-security.tistory.com/10&amp;prev=search&amp;pto=aue</a></li>
</ul>
<p>Now, considering you have basic understanding of the tcache management, with that on our skill set, let&rsquo;s move on to write the wrapper functions to interact with the binary&rsquo;s functionalities:-</p>

<p>Now, with this aside, we will now move on the actual exploitation part, I&rsquo;d say pay attention here as much as possible as the initial ideologyof the exploit is very confusing, but as you move on, you&rsquo;ll understand.</p>
<p>For starting, we will allocate and free chunk 1:-</p>

<p>Now, this will land into the tcache bin:-</p>
<p><img src="/img/ropetwo/chunk1.png" alt=""></p>
<p>Since, we know that calling <code>realloc(0, chunk)</code> will be just <code>free(chunk)</code>, we will allocate a chunk of size <code>0x68</code> and then do <code>realloc(0, chunk_2)</code> where <code>chunk_2</code> represent the chunk we allocated of size <code>0x68</code>.</p>

<p>Doing so,</p>
<p><img src="/img/ropetwo/realloc_free.png" alt=""></p>
<p>As you can see, it is not removed from the global array which is used to store the information about the allocated chunk and size, located at <code>base + 0x4060</code>. Now, moving on, we re-allocate the same chunk at the index <code>0</code> but we shrink the size from the <code>0x68</code> which was <code>free</code>&rsquo;d earlier, and now we update the size to <code>0x18</code>, then we free it a</p>

<p>Now, doing so, we have the same heap chunk at the tcache index 0 as well as on index 5.</p>
<p><img src="/img/ropetwo/dup_entry.png" alt=""></p>
<p>Now, the same chunk reside in different indices, the reason that happened because first off, we allocated chunk of size <code>0x68</code>, then we <code>free</code>&rsquo;d it with the <code>realloc(0, 0, &quot;&quot;)</code> this <code>free'd</code> the region but the global pointer was not NULL, so when we do <code>realloc(0, 0x18, &quot;A&quot;)</code>, this made the chunk which was <code>free</code>&rsquo;d before, making the <code>free</code>&rsquo;d chunk being used and it ended up being reduced to the size <code>0x18</code>, so when we <code>free</code> it again, the chunk will land into the different index of the <code>tcache</code> bin.</p>
<p>Now, we allocate another chunk of size <code>0x48</code>, then we <code>free</code> it again using the <code>realloc</code>:-</p>

<p>Doing so, the heap structure turned out to be:-</p>
<p><img src="/img/ropetwo/chunk2.png" alt=""></p>
<p>Then, we <code>realloc</code> the same chunk as of the same size it was allocated to:-</p>

<p>Now:-</p>

<p>Playing close attention here, the bin at the index 3, has now an entry pointing to itself, as shown by the <code>gef</code>. This aside, now we will allocate at chunk of size <code>0z48</code> which will be retrieved from the index 3, giving the address <code>0x5555555592d0</code>, since the chunk would still be in the same bin because of the duplicate entry. Now, we will re-allocate a chunk of size <code>0x68</code> at the index <code>1</code>, this will retrieve from the index 5 of the <code>tcache</code> bin list, since the same chunk <code>0x5555555592b0</code> is in two different indices, we write the payload <code>&quot;C&quot;*0x18 + p64(0x451)</code>, As the difference between the chunk at index 3 and index 5 of tcache is <code>0x20</code>, we will overwrite the <code>prev_size</code> to <code>0x451</code>, this made the heap structure like this:-</p>

<p><img src="/img/ropetwo/size.png" alt=""></p>
<p>Once we free the chunk, the chunk at the index 1, it&rsquo;ll be:-</p>

<p><img src="/img/ropetwo/free.png" alt=""></p>
<p>Now, we need to at least fill a certain index of the <code>tcache</code> bins in such a way that the chunk we <code>free</code> after filling the <code>tcache</code> lands into the fastbin. Now, the way we fill the <code>tcache</code> here is by allocating the chunk at the index 1, and then reallocating the same chunk by extending the size to a much bigger value and then <code>free</code>&lsquo;ing the chunk.</p>

<p>Doing so, the <code>tcache</code> bin structure becomes:-</p>
<p><img src="/img/ropetwo/loop.png" alt=""></p>
<p>Then, we allocate a chunk of size <code>0x58</code> which will retrieve the chunk from the <code>tcache bin[3]</code>. Now, what we do here is free the chunk saved at the index 1, then the chunk which was allocated at the index <code>0</code> of the global array, we <code>free</code> it with the <code>realloc</code>, now doing so, since the chunk at that index had the size <code>0x451</code> which is more than the <code>tcache</code> structure can hold, this will make them land into the unsorted bin.</p>

<p>Now, doing so, the chunk <code>0x5555555592d0</code> went into the unsorted bin, this chunk remain in the <code>tcache</code> and the <code>unsorted</code> bin:-</p>
<p><img src="/img/ropetwo/unsorted.png" alt=""></p>
<p>Now, since the chunk belongs to <code>unsorted</code> bin, we can edit the <code>fd</code> and <code>bk</code> of it because of the <strong>Use After Free&amp;</strong>, now then, as there&rsquo;s no show function, we populate the <code>fd</code> of that <code>free</code>&rsquo;d chunk in the <code>_IO_2_1_stdout_</code> and the next time, we allocate the chunk, we will get the structure of the <code>_IO_2_1_stdout_</code> which we will be able to modify.</p>

<p><img src="/img/ropetwo/stdout.png" alt=""></p>
<p>Now, we have to allocate chunk carefully since at this point the structure of the heap is not very good, doing anything reckless will mess up the exploit further. Now, what we do is again, allocate a chunk at the index 1, then reallocate the same chunk by shrinking it&rsquo;s size to smaller than it was allocate to, and <code>free</code>&lsquo;ing it, now, when we try to reallocate the chunk 0, to a more smaller size and then <code>free</code> it, doing so, will make the <code>_IO_2_1_stdout_</code> address to the top of the index 3rd of the <code>tcache</code> bin list:-</p>

<p><img src="/img/ropetwo/head.png" alt=""></p>
<p>Now, apparently explaining the structure of the <code>_IO_2_1_stdout_</code> is too much hassle in this already long writeup, so I&rsquo;ll add the references link below for understanding the structure. Now, what we do here is allocate a chuk at the index 0 with the size <code>0x48</code>, which will return the chunk stored from the <code>bin[3]</code>, the given data will be written to the address pointed by the chunk, whhich would look likt his:-</p>

<p><img src="/img/ropetwo/io.png" alt=""></p>
<p>After a <code>puts</code> call, there was lot of addresses dumped to the <code>stdout</code>, which was bit too much, this made it hard to get an exact lLIBC leak, this problem was with the ASLR off, which, in turn ran with the bruteforce works perfectly normal.
So, for the ASLR off part, the leak parsing was something like this:-</p>

<p>Now, what we do is, allocate at the chunk 1 with size <code>0x70</code> and then <code>free</code> it with the use of the <code>realloc</code>, this will push the chunk on the <code>tcache</code> bin list, now we again reallocate the same chunk by shrinking it&rsquo;s size to the <code>0x18</code>, then we allocate the chunk of the same size earlier and edit the <code>fd</code> of the next adjacent chunk to the <code>__free_hook - 0x8</code> and made the size to the <code>0x41</code> which will make it belong to bin of size <code>0x50</code>. Then we <code>free</code> the chunk 1.</p>

<p><img src="/img/ropetwo/free_hook.png" alt=""></p>
<p>Now, we retrieve the chunk and overwrite the <code>free_hook</code> with the system:</p>

<p><img src="/img/ropetwo/system.png" alt=""></p>
<p>Now, we invoke the <code>__free_hook</code> by calling the <code>rm</code> function:-</p>

<p><img src="/img/ropetwo/shell.png" alt=""></p>
<p>The final script for the remote server can be found <a href="https://github.com/D4mianWayne/PwnLand/tree/master/CTFs/RopeTwo_HackTheBox/User">here</a></p>
<p>Running the remote exploit, since ASLR was enabled on the server, we have to bruteforce the last 4 bytes of the <code>_IO_2_1_stdout_</code>, in my case I had the issue with the LIBC leak, with the help of the <a href="https://willsroot.io">FizzBuzz</a>, using the last bytes as <code>p16(0x2760)</code>, doing that so and running the exploit in <code>while</code> loop, I got the shell with 40-60 tries:-</p>
<blockquote>
<p>Issue, after getting the shell as the user <code>r4j</code>, I couldn&rsquo;t read the <code>user.txt</code> which was because of the groups I belonged, using the <code>newgrp</code> and leveraging to the <code>r4j</code> group, I was able to read the user flag.</p></blockquote>
<p><img src="/img/ropetwo/user.png" alt=""></p>
<h1 id="root">Root</h1>
<p>Now, being the user <code>r4j</code> didn&rsquo;t really gave much away with basic enumeration and as I knew that the fact of the root part being the kernel, I went in and checked for the <code>/dev/</code> to look for any suspicious driver, in this case the only thing that stood out more than the other was, <code>ralloc</code>.</p>
<blockquote>
<p>Attachment: The files for root exploitation can be found <a href="https://github.com/D4mianWayne/PwnLand/tree/master/CTFs/RopeTwo_HackTheBox/Root">here</a>.</p></blockquote>
<p>One way I found about the <code>ralloc</code> custom LKM was with the help of <code>dmesg</code>, which showed the follwing message:-</p>
<p><img src="/img/ropetwo/dmesg.png" alt=""></p>
<p>Now, that showed, we have the <code>ralloc</code>, although to start off with the exploitation or even knowing the workflow of this module, I needed to get the <code>ralloc.ko</code>, doing <code>locate ralloc.ko</code>, the file was located at <code>/usr/lib/modules/5.0.0-38-generic/kernel/drivers/ralloc/ralloc.ko</code> which is the default path where kernel modules are stored. Then checking for the kernel version:-</p>

<h5 id="kernel-exploitation">Kernel Exploitation</h5>
<p>There was no publically available CVE for this version of kernel, what left was to dissect the binary and try to understand the workflow and look for any vulnerable part. I am more fan of IDA than of Ghidra, but then again it&rsquo;s just personal preference, at the end you&rsquo;ll have the overall idea. So, moving on, let&rsquo;s reverse engineer the binary and see what the binary really does:-</p>
<p>Now, using the <code>IDA</code> and cleaning up the code a lot, there were 3 functions, in which the <code>rope2_ioctl</code> was one of the functions which was most interesting, the other 2 being <code>rope2_init</code> and <code>rope2_exit</code> are there to handle the intialization and exit operation for the modules, aside from those, the function we need to really focus on was the <code>rope2_ioctl</code> which was as follows:-</p>
<blockquote>
<p>The development of the exploit is done on the QEMU instance which can be foind at the above attached link.
KASLR has been off for the debugging purpose but it is enabled on the RopeTwo machine.
First off, there were four options one could invoke, which were as follows:-</p></blockquote>

<p>The first option, here which can be invoked by giving the <code>0x1000</code> as option, which we will see later on how we will interact with it, here it takes the two options, <code>index</code> and the other being <code>size</code> on the basis of that, it will allocate the chunk on the kernel heap with the <code>kmalloc</code> and save it on the global array with the index given, the upmost <code>index</code> that we could allocate to is <code>0x1F</code> and accepted size is <code>&lt;= 0x400</code>.</p>

<p>The option <code>0x1001</code> here is used to invoke a function which only takes <code>index</code> as the option and then checks if the index exist or not, on the basis of that it calls <code>kfree</code> and release the allocated chunk.</p>

<p>The option was used to write to an allocated region, it takes the <code>index</code>, the <code>size</code> and the pointer to the buffered region.</p>

<p>This function was used to interact in order to read from the allocated region, this takes the <code>index</code>, <code>size</code> and the pointer to the buffer where the contents from the allocated region will be copied, this pointer would from the userland region.</p>
<p>Summarsing the code, we conclude it to:-</p>
<ul>
<li><code>0x1000</code>: Allocate function which takes <code>index</code> and <code>size</code>.</li>
<li><code>0x1001</code>: Free function which takes the <code>index</code>.</li>
<li><code>0x1002</code>: Write function which takes the <code>index</code> <code>size</code> and <code>data</code> to be written.</li>
<li><code>0x1003</code>: Read function which takes <code>index</code>, <code>size</code> and the <code>data</code> where the contents of the chunk would be read.</li>
<li>We can only allocate chunks upto to <code>0x1F</code> times.</li>
</ul>
<p>So, where does the vulnerabilit exists? It exists in the function <code>0x1000</code> which is used for allocation, now let&rsquo;s see where it was:-</p>

<p>The structure of the <code>heap</code> can be considered as:</p>

<p>If you pay close attention to the <code>heap.size + 32</code>, well considering how the <code>heap</code> structure here is, there&rsquo;s an extra 32 bytes added to it. This in turn, allowed us to write 32 bytes more than size of an allocated chunk, same as for read, we can read extra 32 bytes than the chunk&rsquo;s actual size.
So, conlcuding, we have <strong>32</strong> byte extra overflow for read/write. Now, the question arises, how exactly we interact with the service, to do so, I used <code>ioctl</code> to interact with it, the following functions I created:-</p>

<blockquote>
<p>The <code>*.cpio</code> file could be compiled with <code>find . | cpio -H newc -ov -F ../initramfs.cpio</code></p></blockquote>
<p>For the experimentation, I made a QEMU instance of the Linux Kernel <code>5.0.-38</code> with the <code>ralloc.ko</code> as a module loaded to it upon starting, which I uploaded to the github, linked above, try it yourself.</p>
<p>The question we end up at last at exactly how are we supposed to exploit this heap overflow which only gives us the extra 32 bytes to do read/write. Upon the extensive research, I found <a href="https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628#tty_struct">this blog post</a> by <a href="https://twitter.com/ptr-yudai">ptr-yudai</a>, which if translated to the english stated as follows:-</p>
<hr>
<p><strong>Size</strong> : 0x2e0 (kmalloc-1024)
<strong>base</strong> : <code>ops</code> the <code>ptm_unix98_ops</code> leak possible because it refers to. Besides that, it pointed to the data area of ​​the kernel in about two places.
<strong>Heap</strong> : <code>dev</code>, driver<code>leak possible because like many of the object is pointing to the members of the heap and own. The target SLUB has not been investigated. **stack** : I can't seem to leak. **Secure** :</code>/dev/ptmx<code>Open. **Release** : Close the open</code>ptmx<code>. **Remarks** : </code>ops` RIP can be controlled by rewriting.
<strong>Reference</strong> : <a href="https://elixir.bootlin.com/linux/v4.19.98/source/include/linux/tty.h#L283">https://elixir.bootlin.com/linux/v4.19.98/source/include/linux/tty.h#L283</a></p>
<hr>
<p>Considering the above, I then focused on a writeup wrote by the same author for the challenge he created, which can be found <a href="https://hackmd.io/@ptr-yudai/rJp1TpbBU">here</a>, this if try to compare from the <code>ralloc</code>, the initial methodology seems to be same.</p>
<p>Apparently, going in-depth on why this <code>/dev/ptmx</code> is the best target would be better for a seperate post itself, so I am leaving the unncessary part in this challenge context and will explain the things as we move on. To replicate the same methodology to get the RIP control, firstly I allocated a chunk of size <code>0x400</code> which was the meximun size the ioctl can allocate the chunk of and I also opened the <code>ptmx</code> device.</p>
<p>I turned off the KASLR on the QEMU instance and already got the address of the function we needed:-</p>
<ul>
<li><code>commit_creds</code></li>
<li><code>ptm_unix98_ops</code></li>
<li><code>prepare_kernel_creds</code></li>
</ul>

<p>Now, doing so, upon setting up a breakpoint at the <code>rope2_ioctl</code>&rsquo;s <code>kmalloc</code> call and stepping to it, we see the heap structure as:-</p>
<blockquote>
<p>Note: Before debugging do: <code>add-symbol-file ralloc.ko 0xffffffffc0002000</code> in the <code>gdb-gef</code>.</p></blockquote>
<p>Then, moving on, setup a breakpoint at the <code>b *rope2_ioctl + 342</code> and then running the program, once it hits the breakpoint, when we see the memory:-</p>
<p><img src="/img/ropetwo/kmalloc.png" alt=""></p>
<p>Now, considering that, if we see for the memory content, the <code>ptm_unix98_ops</code> object was at <code>heap.size + 32</code>, since <code>heap.size</code> was <code>0x400</code>, the <code>ptm_uniz98_ops</code> was at the <code>0x420</code>. Using the <code>get</code> function, we can have the leak:-</p>
<p><img src="/img/ropetwo/leak.png" alt=""></p>
<p>Now, since we have a leak, this will be useful in retrieving the base address to calculate the address of the function and gadget we will need, for now, since the structure as defined, if we can overwrite the <code>*ops</code> with the help of the fake <code>tty_operations</code> array created from the userland, we can have the RIP control.</p>
<blockquote>
<p>The POC for <code>tty_struct</code> and RIP control can be understood from here: <a href="https://www.lazenca.net/pages/viewpage.action?pageId=29327365#id-07.Use-After-Free(UAF)(feat.tty_struct)-PoCcode">https://www.lazenca.net/pages/viewpage.action?pageId=29327365#id-07.Use-After-Free(UAF)(feat.tty_struct)-PoCcode</a></p></blockquote>
<p>Now compiling the exploit:-</p>

<p>Doing the above, we get the RIP overwritten as <code>0xdeadbeef</code>.</p>
<p><img src="/img/ropetwo/deadbeef.png" alt=""></p>
<p>Now, moving on, we will have to somehow execute the ROP chain which will be <code>commit_creds(init_creds())</code>, and call a function which will spawn shell. As for my initial research, I found out that we can use a gadget like <code>xchg eax, esp</code> and <code>mmap</code> a memory region with the lower 32 bit address of the gadget and store our ROP chain to it, which once the RIP hits the gadget, would exchange the <code>eax</code> and <code>esp</code> would execute instructions from the <code>mmap</code>&rsquo;d region. To do this, I change the 12th index of the <code>fake_tty_operations</code> to the address of the <code>xchg eax, esp</code> gadget and set a breakpoint at the address within gdb:</p>
<blockquote>
<p>The gadget was found with the help of ROPGadget and is from the <code>.text</code> section because of r/w permissions. `</p></blockquote>

<p><img src="/img/ropetwo/gadget.png" alt=""></p>
<p>If we step into the instruction and see the values of both <code>eax</code> &amp; <code>esp</code>, we will see:-</p>
<p><img src="/img/ropetwo/esp.png" alt=""></p>
<p>As seen above, the <code>rsp</code> is now pointing to the loweer 32 bit address of the gadget, now, we can <code>mmap</code> a shared memory page such that it&rsquo;ll be accessible between the kernel and the userland space with:-</p>

<p>Now, time to craft a ROP chain which will be stored in the shared memory region, following is the ROP chain I created:-</p>

<p>Now, to explain the ROP chain, let&rsquo;s break down:-</p>
<ul>
<li><code>pop rdi; ret</code> this will pop the <code>rdi</code> register which is responsible for holding the 1st arguument in the x86_64 systems.</li>
<li><code>init_creds</code>: This will be given into the <code>rdi</code>.</li>
<li><code>commit_creds</code>, doing so, when the the RIP will reach the <code>commit_creds</code>, it&rsquo;ll execute it as <code>commit_creds(init_creds())</code> which will change the <code>UID</code> for the running process to <code>0</code>.</li>
<li>Then, <code>swapgs</code> will let the it back to the userland safely because of the SMAP and KASLR being enabled, then <code>0xdeadbeef</code> for the padding.</li>
<li><code>iretq</code> will store the the flags and register and the RIP.</li>
<li>Followed by the <code>get_shell</code> function, this will be the RIP.</li>
<li>Rest flags would be restored and will be considered.</li>
</ul>
<p>Now, the final exploit looks like this:-</p>

<p>Repacking the <code>initramfs.cpio</code> with the compiled exploit and running it:-</p>
<blockquote>
<p>Compile it with the <code>gcc -static -masm=intel xpl.c -o xpl</code></p></blockquote>
<p><img src="/img/ropetwo/rop.png" alt=""></p>
<p>Now continuing the execution, we will get <code>root</code> on the QEMU instace.</p>
<p><img src="/img/ropetwo/qemu_root.png" alt=""></p>
<p>Now, the exploit is ready, bear in mind the exploit is not very reliable like of those standard exploit one can compile, run and poof, root. For the one I created, I had to reset the machine quite few times, but after some tries, I got the root:-</p>
<blockquote>
<p>The reason I ran the exploit as <code>chromeuser</code> to get <code>root</code> is because the LKM was accessible with the both <code>r4j</code> and <code>chromeuser</code>.</p></blockquote>
<p><img src="/img/ropetwo/root.png" alt=""></p>
<p>Thank you!!!</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/pwn-hackthebox-v8-kernel-heap-tcache-libc-2.29/" rel="tag">pwn, hackthebox, v8, kernel, heap, tcache, libc-2.29</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>




			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<input class="widget-search__field" type="search" placeholder="Search…" value="" name="q" aria-label="Search…">
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="http://localhost:1313/">
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/posts/crushftp-cve-2025-2825/">CVE 2025-2825 - CrushFTP Authentication Bypass Analysis</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/hpe-irs-cve-deep-dive/">Exploring Recent CVEs in HPE Insight Remote Support</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/ivanti-endpoint-manager-xxe-cve-2024-37397/">CVE 2024-37397 - Ivanti Endpoint Manager XXE Vulnerability</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/crushftp-cve-2024-4040/">CVE 2024-4040 - CrushFTP Server-Side Template Injection Vulnerability Analysis</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/soccer-htb/">HackTheBox - Soccer</a></li>
		</ul>
	</div>
</div>
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/cve-analysis/">CVE Analysis</a></li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/hackthebox/">HackTheBox</a></li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/pwning/">Pwning</a></li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/vulnhub/">Vulnhub</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/nmap-ctf-vulnhub/" title="Nmap, Ctf, Vulnhub">Nmap, Ctf, Vulnhub (4)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/java/" title="Java">Java (3)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rce/" title="RCE">RCE (2)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xxe/" title="XXE">XXE (2)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net/" title=".NET">.NET (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/auth-bypass/" title="Auth-Bypass">Auth-Bypass (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cve-2024-37297/" title="CVE-2024-37297">CVE-2024-37297 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cve-2024-4040/" title="Cve-2024-4040">Cve-2024-4040 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cve-2024-53675/" title="CVE-2024-53675">CVE-2024-53675 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cve-2024-53676/" title="CVE-2024-53676">CVE-2024-53676 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cve-2025-2825/" title="CVE-2025-2825">CVE-2025-2825 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dstat-sqlmap-upstream_proxy-websocket/" title="Dstat, Sqlmap, Upstream_proxy, Websocket">Dstat, Sqlmap, Upstream_proxy, Websocket (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/logic-flaw/" title="Logic-Flaw">Logic-Flaw (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/oob-xxe/" title="OOB-XXE">OOB-XXE (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/path-traversal/" title="Path Traversal">Path Traversal (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/pwn-hackthebox-v8-kernel-heap-tcache-libc-2.29/" title="Pwn, Hackthebox, V8, Kernel, Heap, Tcache, Libc-2.29">Pwn, Hackthebox, V8, Kernel, Heap, Tcache, Libc-2.29 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/pwn-tcache-libc-2.27-hackthebox/" title="Pwn, Tcache, Libc-2.27, Hackthebox">Pwn, Tcache, Libc-2.27, Hackthebox (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rop-bof-ret2csu-ctf/" title="Rop, Bof, Ret2csu, Ctf">Rop, Bof, Ret2csu, Ctf (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rop-pwn-bof/" title="Rop, Pwn, Bof">Rop, Pwn, Bof (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rop-pwn-radare2-pwntools/" title="Rop, Pwn, Radare2, Pwntools">Rop, Pwn, Radare2, Pwntools (1)</a>
		<a class="widget-taglist__link widget__link btn widget-taglist__link--all" href="/tags/">View all tags →</a>
	</div>
</div>

</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 .
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>